# **Инструкция по созданию шаблонов**

**Содержание**
- [**Инструкция по созданию шаблонов**](#инструкция-по-созданию-шаблонов)
    - [**Полный шаблон задания**](#полный-шаблон-задания)
    - [**ШАБЛОННЫЙ_ВИД**](#шаблонный_вид)
    - [**ХРАНИЛИЩЕ_ОБЪЕКТОВ**](#хранилище_объектов)
    - [**РЕШЕНИЕ**](#решение)
    - [**СЛУЖЕБНОЕ**](#служебное)
    - [**ТЕСТОВЫЕ_ДАННЫЕ**](#тестовые_данные)
    - [**Использование объектов-параметров**](#использование-объектов-параметров)
    - [**Пример сгенированного варианта**](#пример-сгенированного-варианта)
- [**Формальное описание блоков**](#формальное-описание-блоков)
  - [**Секция 1 - ХРАНИЛИЩЕ_ОБЪЕКТОВ**](#секция-1---хранилище_объектов)
  - [**Секция 2 - ШАБЛОННЫЙ_ВИД**](#секция-2---шаблонный_вид)
  - [**Секция 3 - РЕШЕНИЕ**](#секция-3---решение)
  - [**Секция 4 - СЛУЖЕБНОЕ**](#секция-4---служебное)
  - [**Секция 5 - ТЕСТОВЫЕ_ДАННЫЕ**](#секция-5---тестовые_данные)
- [**Полное описание доступных функций**](#полное-описание-доступных-функций)
  - [**Расширения возможностей генератора**](#расширения-возможностей-генератора)
      - [**Описание функции луа**](#описание-функции-луа)
      - [**Внешние модули**](#внешние-модули)

******************

Рассмотрим некоторый пример: имеется следующее задание и нужно сделать новую версию данного задания.

Листинг 1 - Первоначальное задание
> Написать программу для вычисления функции  $y = f(x)$
> - $y = \frac{\cos{x}}{(x + 10)}$ при x < -3
> - $y = e^{0.1x}$        при -3 <= x < 4
> - $y = \lg{x}$            при 4 <= x < 6
> - $y = \sin{x}$       при x >= 6

Для создания нового варианта необходимо выделить основные части задания: 
* статические - общие для всех вариантов части;
* динамические - генерируемые части.

Листинг 2 - общий вид задания
> Написать программу для вычисления функции $y = f(x)$
> - y = **@выражение 1@** при x < **@1-ый диапазон@**
> - y = **@выражение 2@** при **@1-ый диапазон@** <= x < **@2-ой диапазон@**
> - y = **@выражение 3@** при **@2-ой диапазон@** <= x < **@3-ий диапазон@**
> - y = **@выражение 4@** при x <= **@3-ий диапазон@**

В листинге 2 динамические части были помещены между символами `@`. При создании нового варианта, внимание будет уделяться только данным частям.

### **Полный шаблон задания**

Рассмотрим шаблон предназначенный для генерации вышеописанного задания.

Листинг 3 - готовый шаблон
```
1. | ----
2. | ШАБЛОННЫЙ_ВИД   // данный блок содержит общий вид задания
3. | Написать программу для вычисления функции y = f(x)
4. |    y = @выр1.выражение@ где x1 < @1-ый диапазон@
5. |    y = @выр2.выражение@ где @1-ый диапазон@ <= x1 < @2-ой диапазон@
6. |    y = @выр3.выражение@ где @2-ой диапазон@ <= x1 < @3-ий диапазон@
7. |    y = @выр4.выражение@ где x1 >= @3-ий диапазон@
8. | ----
9. | ХРАНИЛИЩЕ_ОБЪЕКТОВ // хранилище всех объектов-параметров
10.| выр1 : #создатьАВ(5); // генерация арифм. выражений
11.| выр2 : #создатьАВ(5);
12.| выр3 : #создатьАВ(5);
13.| выр4 : #создатьАВ(5);
14.| 1-ый диапазон : #случайноеДробное( 0.0  , 5.0); // в диапазоне [0.0; 5.0) типа double 
16.| 2-ой диапазон : #случайноеДробное( 5.0  , 10.0); // в диапазоне [5.0; 10.0) типа double
16.| 3-ий диапазон : #случайноеДробное( 10.0 , 15.0); // в диапазоне [10.0; 15.0) типа double
17.| ----
18.| РЕШЕНИЕ // данная секция хранит эталонное решение
19.| #include <cmath>
20.| #include <iostream>
21.| using namespace std;
22.| int main()
23.| {
24.|     double y = 0.0;
25.|     double x1;
26.|     cin >> x1;
27.|     if ( x1 <  @1-ый диапазон@) // подстановка 1-го диапазона
28.|     {        
29.|         @выр1.код@ // подстановка сгенерированного кода для вычисления выражения 1
30.|     }
31.|     else if (x1 >=  @1-ый диапазон@ && x1 < @2-ой диапазон@) // диапазон 1 и 2
32.|     {
33.|         @выр2.код@ // подстановка сгенерированного кода для вычисления выражения 2
34.|     }
35.|     else if (x1 >= @2-ой диапазон@ && x1 < @3-ий диапазон@) // диапазон 2 и 3
36.|     {
37.|     	@выр3.код@ // подстановка сгенерированного кода для вычисления выражения 3
38.|     }
39.|     else if (x1 >= @3-ий диапазон@) // подстановка 3-го диапазона
40.|     {
41.|         @выр4.код@ // подстановка сгенерированного кода для вычисления выражения 4
42.|     }
43.|     cout << y << "\n";
44.|     system("pause");
45.|     return 0;
46.| }
47.| ----
48.| СЛУЖЕБНОЕ // данная секция хранит настройки генератора
49.|   знаки_арифм : + | - | * | / | ^;
50.| функции_арифм : sin | cos | sqrt | tan | ln | log10;
51.| ----
52.| ТЕСТОВЫЕ_ДАННЫЕ // здесь хранятся тестовые данные для прогонов
53.| Тест1 : #случайноеДробное(100 , 200, 1000); //  генерация в ран тайме 1000 double значений
54.| Тест2 : 1.0| 2.0| 3.0| 4.0| 5.0| 6.0| 7.0| 8.0| 9.0| 10.0;
55.| ----
```

### **ШАБЛОННЫЙ_ВИД**
Первой секцией в листинге 3 является [*ШАБЛОННЫЙ_ВИД*](#полный-шаблон-задания) (*строки 2-7*), блок в котором содержится общий вид задания.

> 2. | ШАБЛОННЫЙ_ВИД
> 3. | Написать программу для вычисления функции y = f(x)
> 4. |    y = **@выр1.выражение@** где x1 < **@1-ый диапазон@**
> 5. |    y = **@выр2.выражение@** где **@1-ый диапазон@** <= x1 < **@2-ой диапазон@**
> 6. |    y = **@выр3.выражение@** где **@2-ой диапазон@** <= x1 < **@3-ий диапазон@**
> 7. |    y = **@выр4.выражение@** где x1 >= **@3-ий диапазон@**

Выделенные части - это объекты-параметры, объявленные в секции `ХРАНИЛИЩЕ_ОБЪЕКТОВ`. При генерации вместо объектов-параметров будут подставляться конкретные значения присвоенные этим параметрам.

### **ХРАНИЛИЩЕ_ОБЪЕКТОВ**

[*ХРАНИЛИЩЕ_ОБЪЕКТОВ*](#полный-шаблон-задания) (*строки 9-16*) - содержит все объекты-параметры, применяемые в шаблоне. *Объекты-параметры* своего рода переменные, которые хранят либо уже готовый набор строк, либо исполняемую функцию.

Для примера обратимся к строке 10
>10.| выр1 : #создатьАВ(5);

здесь объект-параметр `выр1` содержит исполняемую функцию `#создатьАВ(5)` (расшифровывается как _создать арифметическое выражение_), данная функция генерирует случайное арифметическое выражение сложность 5 (сумма знаков и функций, например: _sin_, _cos_, _log_, _+_, _-_ и т.д.).

Функция `#создатьАВ(3)` например может сгенерировать выражение `cos((-2 / x1) * x1)`, сложность данного выражения 3 = cos, знак / и знак *. Сгенерированное выражение поместится в объект-параметр `выр1`

Cледующим уникальным объектом-параметром является:
> 14.| 1-ый диапазон : #случайноеДробное( 0.0  , 5.0);

Функция `#случайноеДробное(0.0, 5.0)` возвращает случайное число типа `double` из диапазона от 0.0 до 5.0 (*не включая верхнюю границу*)

### **РЕШЕНИЕ**

[*РЕШЕНИЕ*](#полный-шаблон-задания) (*строки 18-46*) - потенциальное эталонное решение, созданное преподавателем и которое в дальнейшем будет использоваться для проверки студенческих работ. Здесь все работает по тому же принципу как и в секции `ШАБЛОННЫЙ_ВИД`, есть общие места, а есть места подстановки объектов-параметров.

### **СЛУЖЕБНОЕ**

[*СЛУЖЕБНОЕ*](#полный-шаблон-задания) (*строки 48-50*) - настройки генератора. На данный момент есть два значения `функции_арифм` и `знаки_арифм`, данные настройки отвечают за знаки и функции, которые будут использоваться при генерации арифметических выражений.

### **ТЕСТОВЫЕ_ДАННЫЕ**

Последний блок в шаблоне это [*ТЕСТОВЫЕ_ДАННЫЕ*](#полный-шаблон-задания) (*строки 52-54*), содержаший тестовые данные, которые будут применяться при тестировании работ студентов, здесь также как и в `ХРАНИЛИЩЕ_ОБЪЕКТОВ` можно создавать объекты-параметры, которые будут содержать либо уже заготовленные тестовые данные (*строка 54*) или содержать функцию `#случайноеДробное(100, 200, 1000)`, это все таже функция для генерации случайных значений, лишь с тем отличием, что здесь создается не одно значение, а сразу 1000.

### **Использование объектов-параметров**

Для того чтобы использовать объект-параметр необходимо использовать следующий синтаксис:

```
@имя-объекта-параметра@
```

Например:
```
до подстановки:
    если x < @1-ый диапазон@ то ...
после подстановки:
    если x < 3.3 то ...
```

Некоторые функции возвращают несколько значений. Например функция `#создатьАВ` возвращает 2 значения: выражение и код. Для того чтобы использовать нужное значение достаточно использовать следующую конструкцию:
```
@имя-объекта-параметра.имя-значения@
```
Например:
```
до подстановки:
    y - @выр1.выражение@
    код на c++ - @выр1.код@
после подстановки:
    y - cos((-2 / x1) * x1)
    код на c++ - if (x1 != 0 ) y = cos((-2 / x1) * x1); else y = 0.0;
```

Все функции, а также значения которые они возращают описаны [*здесь*](#полное-описание-доступных-функций)

### **Пример сгенированного варианта**

*ШАБЛОННЫЙ_ВИД*

Написать программу для вычисления функции y = f(x)
 *  $y = \tan{(-18 * x1)} - \frac{-23 + x1}{x1}$ где x1 < 3.90
 *  $y = \frac{(\sqrt{(15)^{x1}})}{(8)^{x1}}$ где 3.90 <= x1 < 8.71
 *  $y = \ln{(21 - x1 - \ln{(-2 * x1)})}$ где 8.71 <= x1 < 12.59
 *  $y = 16 * x1 - x1 - (x1)^{21} - -1$ где x1 >= 12.59
  
*РЕШЕНИЕ*
```
#include <cmath>
#include <iostream>
using namespace std;
int main()
{
    double y = 0.0;
    double x1;
    cin >> x1;
    if ( x1 <  3.90) 
    {        
        if ( (fabs((x1)) > 1.0e-6)) y = tan(-18 * x1) - (-23 + x1) / (x1); else y = 0.0; 
    }
    else if (x1 >=  3.90 && x1 < 8.71) 
    {
        if ( ((pow(15, x1)) > 1.0e-6) && (fabs((pow(8, x1))) > 1.0e-6)) y = (sqrt(pow(15, x1))) / (pow(8, x1)); else y = 0.0; 
    }
    else if (x1 >= 8.71 && x1 < 12.59) 
    {
    	if ( ((-2 * x1) > 1.0e-6 && fabs((-2 * x1) - 1.0) > 1.0e-6) && ((21 - x1 - ln(-2 * x1)) > 1.0e-6 && fabs((21 - x1 - ln(-2 * x1)) - 1.0) > 1.0e-6)) y = ln(21 - x1 - ln(-2 * x1)); else y = 0.0; 
    }
    else if (x1 >= 12.59) 
    {
        y = 16 * x1 - x1 - pow(x1, 21) - -1; 
    }
    cout << y << "\n";
    system("pause");
    return 0;
}
```
*ТЕСТОВЫЕ_ДАННЫЕ (json)*
```
"Тест1 : #случайноеДробное(100.0 , 200.0, 1000);\r\nТест2 : 1.0| 2.0| 3.0| 4.0| 5.0| 6.0| 7.0| 8.0| 9.0| 10.0;"
```


# **Формальное описание блоков**

Шаблон задания состоит из пяти секций ([*шаблон*](#полный-шаблон-задания) строки = 2, 9, 18, 48, 52), также необходимо обратить внимание на то, что начало каждой секции отделяется от предыдущей последовательностью символов : `----\n`, данная последовательность должна заканчиваться концом строки `\n`.

```         
1. | ----
2. | ШАБЛОННЫЙ_ВИД

8. | ----
9. | ХРАНИЛИЩЕ_ОБЪЕКТОВ

17.| ----
18.| РЕШЕНИЕ
      
47.| ----
48.| СЛУЖЕБНОЕ
      
51.| ----
52.| ТЕСТОВЫЕ_ДАННЫЕ   
```

**Примечание:**

Для более удобного расшифровывания шаблон-файл есть набор метасимволов, который предназначен для разделения лексем. К ним относятся [ `: ; | " @` ]. Eсли необходимо использовать эти символы в качестве текстовых знаков, можно использовать экранирующий символ [ `\` ]. При подстановке в текст символ [ `\` ] будет убираться.

***Данное правило относится лишь к объектам-параметрам, во всех остальных местах никакие экранирующие символы использовать не нужно.***

> ### Пример:
> **В данном случае все знаки используются для разделения лексем**
> - выр1 **:** sin x + 23 **|** x * 2 + x * x **;**
> 
> **В следующих примерах некоторые символы выступают в качестве текстовых знаков. При использовании данных объектов-параметров в тексте - символ `\` удалится**
> - задание : реализовать возведение в степень , не используя математическую библиотеку, для чисел в диапазоне [1 **\\;** 100];
> - оператор : оператор **\\|\\|** является логическим ИЛИ;


## **Секция 1 - ХРАНИЛИЩЕ_ОБЪЕКТОВ**

`ХРАНИЛИЩЕ_ОБЪЕКТОВ` - хранит объекты-параметры. 

`Объект-параметр` - именованная переменная, хранящая строку (здесь подразумевается неограниченный набор символов). Объект-параметр может содержать как уже готовое значение так и исполняемую функцию (при вызове параметра где-либо в шаблоне функция сначала исполняется и подставляется уже результат, который выдала функция).

Объект-параметр имеет следующий синтаксис :
```
объект_параметр = “имя объекта-параметра” “:” значение { "|" значение} “;”
значение        =  наборы строк |
                  “#имя_функции({аргументы функции [,]})”
```
Если описывать проще то синтаксис можно представить следующим образом (пробелы не играют никакой роли):
```
имя параметра : содержимое объекта параметра;
  выр1 : sin(x) + x * 10 + 5 | #создатьАВ(4) | 10 * x + 123;
```

1. Имя параметра может содержать любые символы (исключение составляют специальные символы - [ ` : , ; | " \n` ]);
2. Содержимое может являться либо функцией либо уже готовым значением, перемешивание недопустимо;
3. Объекту-параметру изначально можно задать несколько значений, используя символ [ `|` ]. В дальнейшем выберется одно случайное значение, которое и будет использоваться.

Если выражение содержит несколько параметров, то можно выбрать необходимое значение путем указания ключа значения.


```
имя параметра [значение] : [ключ] содержимое объекта параметра;
1.  выр1 [0] : [0] sin(x) + x * 10 + 5 |
               [1] #создатьАВ(4)       |
               [2] 10 * x + 123;

2.  выр1 [1] : sin(x) + x * 10 + 5 | 
               #создатьАВ(4)       | 
               10 * x + 123;

3. выр1 [мой_ключ] : sin(x) + x * 10 + 5 |
                     #создатьАВ(4)       | 
                     [мой_ключ] 10 * x + 123;

4. случайное_значение : #случайноеЦелое(0,3);
   выр1 [@случайное_значение@] : sin(x) + x * 10 + 5 |
                                 #создатьАВ(4)       | 
                                 10 * x + 123;
```

Выше описано 4 примера выбора значения по ключу. по умолчанию все значения пронумерованы от 0 до некоторого значения.
Можно явно указать ключ для каждого значения, заключив его в скобки `[ключ]`. Ключ может быть числом, строкой, набор символов и т.д.
Если необходимо выбрать случайное значение, то можно сгенерировать случайное число и использовать его в качестве ключа, так как это представлено в примере 4.

* В примере 1 будет выбрано `sin(x) + x * 10 + 5`
* В примере 2 будет выбрано `#создатьАВ(4)`
* В примере 3 будет выбрано `10 * x + 123`

Использование объекто-параметров описано [*здесь*](#использование-объектов-параметров)

## **Секция 2 - ШАБЛОННЫЙ_ВИД**

Данная секция шаблон-файла содержит конкретный вид варианта задания. В данном блоке можно и нужно использовать ранее описанные объекты-параметры.

Обратимся к строкам `1-8`
```
1. | ----
2. | ШАБЛОННЫЙ_ВИД   // данный блок содержит общий вид задания
3. | Написать программу для вычисления функции y = f(x)
4. |  -  y = $@выр1.выражение@$ где x1 < @1-ый диапазон@
5. |  -  y = $@выр2.выражение@$ где @1-ый диапазон@ <= x1 < @2-ой диапазон@
6. |  -  y = $@выр3.выражение@$ где @2-ой диапазон@ <= x1 < @3-ий диапазон@
7. |  -  y = $@выр4.выражение@$ где x1 >= @3-ий диапазон@
8. | ----
```

Данный блок содержит задание в которое будут подставляться ранее описанные объекты-параметры: `@выр1@`, `@выр2@`, `@выр3@`, `@выр4@`, `@1-ый диапазон@`, `@2-ый диапазон@`, `@3-ый диапазон@`. 

Рассмотрис строку 4

> 4.| `-` y = `$`@выр1.выражение@`$` `**`где x1 < @1-ый диапазон@`**`

Помеченные символы являются частью языка разметки `markdown` и используются для форматирования текста, использование `markdown` не является обязательным, если у вас нет времени на изучение `markdown`, вы можете игнорировать использование данного языка и описывать все так как вы привыкли.

Примерный вид готового задания с использованием форматирования может выглядеть следующим образом:

> Написать программу для вычисления выражения $y = f(x)$:
> 
> - $y = \frac{x1}{-6} + 3$  **где x1 < 3**
> - $y = \log(\cos(2^{-6 * x1})))$  **где 3 <= x1 < 7**
> - $y = -10 + (\sin(9 - x1) * 8)$  **где 7 <= x1 < 14**
> - $y = \sqrt{6 * (-1 + x1)}$  **где x1 >= 14**

## **Секция 3 - РЕШЕНИЕ**

`РЕШЕНИЕ` - хранит эталонное решения для задания. Эталонное решение компилируется и используется для тестирования других программ предназначенных для выполнения поставленных задач.

Данная секция является копией `ШАБЛОННОГО_ВИДА`, здесь также можно использовать объекты-параметры. Отличительная черта данного блока это данные, а именно код который должен успешно компилироваться или интерпретироваться, привязки к определенному ЯП нет. Из _'коробки'_ генератор обращается к модулю проверки заданий, который компилирует эталонное решения, используя `g++` (подразумевается, что решение написано ЯП `C++`).

## **Секция 4 - СЛУЖЕБНОЕ**

`СЛУЖЕБНОЕ` - секция отвечающая за настройку генератора. На данный момент есть лишь 2 параметра :

* `знаки_арифм` – отвечает за операции, которые будут использоваться во время генерации арифметических выражений;
* `функции_арифм` – отвечает за функции, которые будут использоваться во время генерации арифметических выражений.

## **Секция 5 - ТЕСТОВЫЕ_ДАННЫЕ**

`ТЕСТОВЫЕ_ДАННЫЕ` - секция которая содержит данные для тестирования эталонного решения и решения, присланного обучаемым;

Данный блок схож с `ХРАНИЛИЩЕМ_ОБЪЕКТОВ`, здесь также описываются объекты-параметры. В данной секции можно указывать заготовленные данные через запятую или же использовать какие-либо функции, например использовать функцию для генерации большого количества случайных чисел в диапазоне и т.д.


# **Полное описание доступных функций**
 * `#случайноеЦелое( нижняя_граница , верхняя_граница {, количество})` - генерирует случайное число в границе [ нижняя_граница, верхняя_граница) целого типа. Если необходимо сгенерировать сразу несколько значений используется дополнительный параметр “количество”, в таком случае сгенерированные числа будут разделены запятыми;
 * `#случайноеДробное( нижняя_граница , верхняя_граница {, количество})` - функция схожая с *#случайноеЦелое*, но генерирует числа с плавающей точкой двойной точности;
 * `#создатьАВ(сложность {, граница , тип , количество переменных})` - генерирует выражение некоторой сложности (сложность указывает количество знаков и функций (например log, sin и т.д.)), граница указывает диапазон генерации констант [-граница, граница) по умолчанию = [-100; 100), тип указывает на тип генерируемых констант (`дробное` или `целое`), по умолчанию = `целое`, количество переменных, указывает на зависимость выражения от количества переменных (от 1 до бесконечности), по умолчанию = 1.

    Список возвращаемых значений:
    > вычисление - вычисление выражения на языке C++
    > 
    > условие - условие для вычисления выражения (деление на 0 и т.д.)
    >
    > выражение - содержит выражение в формате KaTeX
    >  
    > код - код для вычисления выражения в формате `if (условие) y = вычисление; else y = 0.0;`
* `#создатьАВдробь(сложность {, граница , тип , количество переменных})` - копия функции *#создатьАВ* с тем отличием, что данная функция всегда генерирует дробь в формате :
  $$y = \frac{числитель}{знаменатель}$$   

## **Расширения возможностей генератора**

Расширение функциональных возможностей генератора производится с помощью внешних модулей написанных на скриптовым языке Lua. Пользователь может использовать внешние модули во время исполнения, без необходимости изменять исходный код генератора. Ограничений на возвращаемые данные нет: функции могут вовзращать сколько угодной значений, тип возвращаемых данных также не играет роли. Можно возвращать таблицы, несколько таблицы, целые и дробные значения, строки и т.д.

Зачем это нужно?

Ответ прост - предоставить набор функций достаточных для генерации любого задания невозможно, потому легче создать механизм динамического добавления функций. Например вам понадобилось сгенерировать для тестирования отсортированный массив, в порядке убывания или возврастания, стандартные функции этого не позволяют, потому можно создать свой модуль и использовать его в шаблоне ([_далее_](#внешние-модули) это будет показано).

#### **Описание функции луа**

`#луа(код_на_луа)` - данная функция является второстепенной и предназначена для выполнения кода на `Lua` внутри шаблона.
```
было =
    число : #lua("
            math.randomseed(os.time());
            return math.random(100);
       ");
стало =
    число : 88;
```

#### **Внешние модули**
#путь_до_модуля.метод(аргументы) - это способ расширения стандартного набора функций с помощью скриптов написанных на `lua`. Допустим вам необходима функция которой нет, вы можете написать модуль на `lua`, поместить данный модуль в какую-либо директорию и вызвать ее описанным способом. Путь до модуля может быть как полным, так и относительным.
```
Внешний модуль написанный на lua. Имя файла rnd_arr.lua. Расположен в поддиректории my_modules.
--------------------
Дерево директории Generator:

---
 |--*.dll *.json другие директории
 | 
 |--Generator.exe
 |--Generator.dll
 |
 |--my_modules
        |
        |--rnd_arr.lua

--------------------
МОДУЛЬ rnd_arr.lua
--------------------
lib = {}

-- генерация упорядоченного массива
function lib.make_array(count, min, max)
    math.randomseed(os.time()) -- задаем случайное зерно
    local digits = {} -- массив с числами
     for i = 1,count do -- генерация новых значений
        digits[i] = math.random( min,max )
    end
    -- сортировка
    table.sort(digits, function (a, b) return (a < b) end)
    -- возвращаем таблицу
    return digits
end

return lib -- возвращаем модуль
--------------------
Вызов метода из внешнего модуля:

модуль : my_modules/rnd_arr;
массив1 : #@модуль@.make_array(100,-250.0, 250.0); // способ 1
массив2 : #my_modules/rnd_arr.make_array(100,-250.0, 250.0); // способ 2
```

